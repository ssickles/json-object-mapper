{"version":3,"file":null,"sources":["../src/main/ReflectHelper.ts","../src/main/DecoratorMetadata.ts","../src/main/DeserializationHelper.ts","../src/main/SerializationHelper.ts","../src/main/index.ts"],"sourcesContent":["/**\r\n * Helper functions for JS reflections.\r\n */\r\nimport 'reflect-metadata';\r\nimport { AccessType, JsonPropertyDecoratorMetadata } from './DecoratorMetadata';\r\n\r\n/**\r\n * Reflect Metadata json properties storage name.\r\n */\r\nexport const JSON_PROPERTY_DECORATOR_NAME = 'JsonProperty';\r\nexport const METADATA_JSON_IGNORE_NAME = 'JsonIgnore';\r\n\r\n/**\r\n * Returns the JsonProperty decorator metadata.\r\n */\r\nexport const getJsonPropertyMetadata = (target: any, propertyName: string): JsonPropertyDecoratorMetadata => {\r\n    if (target.constructor.prototype._serializeMap) {\r\n        return target.constructor.prototype._serializeMap[propertyName];\r\n    } else {\r\n        return { name: propertyName, type: getType(target, propertyName), required: false, access: AccessType.BOTH };\r\n    }\r\n};\r\n\r\n/**\r\n * Returns the JsonProperty name (if any) associated with the object instance.\r\n * If any JsonProperty metadata found, it returns the key name as the name of the property.\r\n */\r\nexport const getKeyName = (target: any, key: string): string => {\r\n    const metadata: JsonPropertyDecoratorMetadata = getJsonPropertyMetadata(target, key);\r\n    // tslint:disable-next-line:triple-equals\r\n    if (metadata != undefined && metadata.name != undefined) {\r\n        return metadata.name;\r\n    } else {\r\n        return key;\r\n    }\r\n};\r\n\r\n/**\r\n * Returns the JsonPropertyDecoratorMetadata for the property\r\n */\r\nexport const setJsonPropertyMetadata = (metadata: JsonPropertyDecoratorMetadata) => {\r\n    return (target: Object, propertyName: string) => {\r\n        if (!target.constructor.prototype._serializeMap) {\r\n            target.constructor.prototype._serializeMap = {};\r\n        }\r\n        if (!metadata) { metadata = {}; }\r\n        if (!metadata.name) { metadata.name = propertyName; }\r\n        if (!metadata.type) { metadata.type = getType(target, propertyName); }\r\n        target.constructor.prototype._serializeMap[propertyName] = metadata;\r\n    };\r\n};\r\n\r\n/**\r\n * Returns the JsonIgnoreDecoratorMetadata for the property\r\n */\r\nexport const setJsonIgnoreMetadata = () => {\r\n    return (target: any, propertyKey: string) => {\r\n        Reflect.defineMetadata(METADATA_JSON_IGNORE_NAME, true, target, propertyKey);\r\n    };\r\n};\r\n\r\n/**\r\n * Checks to see if the specified type is a standard JS object type.\r\n */\r\nexport const isSimpleType = (typeName: string): boolean => {\r\n    switch (typeName) {\r\n        case Constants.STRING_TYPE: return true;\r\n        case Constants.NUMBER_TYPE: return true;\r\n        case Constants.BOOLEAN_TYPE: return true;\r\n        case Constants.DATE_TYPE: return true;\r\n        case Constants.STRING_TYPE_LOWERCASE: return true;\r\n        case Constants.NUMBER_TYPE_LOWERCASE: return true;\r\n        case Constants.BOOLEAN_TYPE_LOWERCASE: return true;\r\n        case Constants.DATE_TYPE_LOWERCASE: return true;\r\n        default: return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Returns the the instance type name by looking at the constructor name.\r\n * Stupid IE does not have name property! Hence the hack.\r\n */\r\nexport const getTypeNameFromInstance = (instance): string => {\r\n    return instance.toString().trim().split(/[\\s\\()]/g)[1];\r\n};\r\n\r\nconst getType = (instance: any, key: string): any => {\r\n    return Reflect.getMetadata('design:type', instance, key);\r\n};\r\n\r\nexport const isArrayType = (instance: any, key: string): boolean => {\r\n    return Array === getType(instance, key);\r\n};\r\n\r\nexport const getTypeName = (instance, key): string => {\r\n    const type = getType(instance, key);\r\n    // tslint:disable-next-line:triple-equals\r\n    if (type != undefined) {\r\n        return getTypeNameFromInstance(type);\r\n    }\r\n    return type;\r\n};\r\n\r\nexport const Constants = {\r\n    OBJECT_TYPE: 'Object',\r\n    OBJECT_TYPE_LOWERCASE: 'object',\r\n    STRING_TYPE: 'String',\r\n    STRING_TYPE_LOWERCASE: 'string',\r\n    NUMBER_TYPE: 'Number',\r\n    NUMBER_TYPE_LOWERCASE: 'number',\r\n    BOOLEAN_TYPE: 'Boolean',\r\n    BOOLEAN_TYPE_LOWERCASE: 'boolean',\r\n    DATE_TYPE: 'Date',\r\n    DATE_TYPE_LOWERCASE: 'date',\r\n    ARRAY_TYPE: 'Array',\r\n    ARRAY_TYPE_LOWERCASE: 'array',\r\n    FROM_ARRAY: 'fromArray'\r\n};\r\n\r\nexport const getCachedType = (type: any, cache: Object): any => {\r\n    // tslint:disable-next-line:triple-equals\r\n    const typeName: string = type.getJsonObjectMapperCacheKey != undefined ? type.getJsonObjectMapperCacheKey() : getTypeNameFromInstance(type);\r\n    if (!cache[typeName]) {\r\n        cache[typeName] = new type();\r\n    }\r\n    return cache[typeName];\r\n};\r\n","import { setJsonIgnoreMetadata, setJsonPropertyMetadata } from './ReflectHelper';\r\n\r\n/**\r\n * Decorator metadata definition for JsonProperty\r\n */\r\nexport interface JsonPropertyDecoratorMetadata {\r\n    name?: string; // name of the JSON property to map\r\n    required?: boolean; // is this field required in the JSON object that is being deserialized\r\n    access?: AccessType; // is this serializable and de-serializable\r\n    type?: any; // the type of Object that should be assigned to this property\r\n    serializer?: any; // Serializer for the type\r\n    deserializer?: any; // deserializer for the type\r\n}\r\n\r\nexport enum AccessType {\r\n    READ_ONLY, WRITE_ONLY, BOTH\r\n}\r\n\r\nexport interface Serializer {\r\n    serialize(value: any): any;\r\n}\r\n\r\nexport interface Deserializer {\r\n    deserialize(value: any): any;\r\n}\r\n\r\n/**\r\n * JsonProperty Decorator function.\r\n */\r\nexport const JsonProperty = (metadata?: JsonPropertyDecoratorMetadata | string): any => {\r\n    if (typeof metadata === 'string') {\r\n        metadata = { name: metadata as string };\r\n    }\r\n    return setJsonPropertyMetadata(metadata);\r\n};\r\n\r\n/**\r\n * Decorator for specifying cache key.\r\n * Used for Serializer/Deserializer caching.\r\n *\r\n * @export\r\n * @param {string} key\r\n * @returns\r\n */\r\nexport const CacheKey = (key: string): Function => {\r\n    return (f: Function) => {\r\n        const functionName = 'getJsonObjectMapperCacheKey';\r\n        const functionImpl = new Function(`return '${key}';`);\r\n        f[functionName] = functionImpl;\r\n    };\r\n};\r\n\r\n/**\r\n * JsonIgnore Decorator function.\r\n */\r\nexport const JsonIgnore = (): Function => {\r\n    return setJsonIgnoreMetadata();\r\n};\r\n\r\n/**\r\n * Json convertion error type.\r\n */\r\nexport class JsonConverstionError {\r\n    private json: string;\r\n    private message: string;\r\n    private stack: string;\r\n\r\n    constructor(message: string, json: string) {\r\n        this.json = json;\r\n        this.message = message;\r\n        this.stack = (new Error()).stack;\r\n    }\r\n}\r\n","import { AccessType, Deserializer, JsonConverstionError , JsonPropertyDecoratorMetadata} from './DecoratorMetadata';\r\nimport { Constants, getCachedType, getJsonPropertyMetadata, getTypeName, getTypeNameFromInstance, isArrayType, isSimpleType, METADATA_JSON_IGNORE_NAME } from './ReflectHelper';\r\n\r\ndeclare var Reflect;\r\n\r\nconst SimpleTypeCoverter = (value: any, type: string): any => {\r\n    return type === Constants.DATE_TYPE ? new Date(value) : value;\r\n};\r\n\r\n/**\r\n * Deserializes a standard js object type(string, number and boolean) from json.\r\n */\r\nexport const DeserializeSimpleType = (instance: Object, instanceKey: string, type: any, json: any, jsonKey: string) => {\r\n    try {\r\n        instance[instanceKey] = json[jsonKey];\r\n        return [];\r\n    } catch (e) {\r\n        // tslint:disable-next-line:no-string-literal\r\n        throw new JsonConverstionError(`Property '${instanceKey}' of ${instance.constructor['name']} does not match datatype of ${jsonKey}`, json);\r\n    }\r\n};\r\n\r\n/**\r\n * Deserializes a standard js Date object type from json.\r\n */\r\nexport const DeserializeDateType = (instance: Object, instanceKey: string, type: any, json: any, jsonKey: string): Array<ConversionFunctionStructure> => {\r\n    try {\r\n        instance[instanceKey] = new Date(json[jsonKey]);\r\n        return [];\r\n    } catch (e) {\r\n        // tslint:disable-next-line:no-string-literal\r\n        throw new JsonConverstionError(`Property '${instanceKey}' of ${instance.constructor['name']} does not match datatype of ${jsonKey}`, json);\r\n    }\r\n};\r\n\r\n/**\r\n * Deserializes a JS array type from json.\r\n */\r\nexport let DeserializeArrayType = (instance: Object, instanceKey: string, type: any, json: Object, jsonKey: string): Array<ConversionFunctionStructure> => {\r\n    const jsonObject = (jsonKey !== undefined) ? (json[jsonKey] || []) : json;\r\n    const jsonArraySize = jsonObject.length;\r\n    const conversionFunctionsList = [];\r\n    const arrayInstance = [];\r\n    instance[instanceKey] = arrayInstance;\r\n    if (jsonArraySize > 0) {\r\n        for (let i = 0; i < jsonArraySize; i++) {\r\n            if (jsonObject[i]) {\r\n                const typeName = getTypeNameFromInstance(type);\r\n                if (!isSimpleType(typeName)) {\r\n                    const typeInstance = new type();\r\n                    conversionFunctionsList.push({ functionName: Constants.OBJECT_TYPE, instance: typeInstance, json: jsonObject[i] });\r\n                    arrayInstance.push(typeInstance);\r\n                } else {\r\n                    arrayInstance.push(conversionFunctions[Constants.FROM_ARRAY](jsonObject[i], typeName));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return conversionFunctionsList;\r\n};\r\n\r\n/**\r\n * Deserializes a js object type from json.\r\n */\r\nexport const DeserializeComplexType = (instance: Object, instanceKey: string, type: any, json: any, jsonKey: string): Array<ConversionFunctionStructure> => {\r\n    const conversionFunctionsList = [];\r\n\r\n    let objectInstance;\r\n    /**\r\n     * If instanceKey is not passed on then it's the first iteration of the functions.\r\n     */\r\n    // tslint:disable-next-line:triple-equals\r\n    if (instanceKey != undefined) {\r\n        objectInstance = new type();\r\n        instance[instanceKey] = objectInstance;\r\n    } else {\r\n        objectInstance = instance;\r\n    }\r\n\r\n    let objectKeys: string[] = Object.keys(objectInstance);\r\n    objectKeys = objectKeys.filter((item: string) => {\r\n        return !Reflect.hasMetadata(METADATA_JSON_IGNORE_NAME, objectInstance, item);\r\n    });\r\n    objectKeys.forEach((key: string) => {\r\n        /**\r\n         * Check if there is any DecoratorMetadata attached to this property, otherwise create a new one.\r\n         */\r\n        let metadata: JsonPropertyDecoratorMetadata = getJsonPropertyMetadata(objectInstance, key);\r\n        if (metadata === undefined) {\r\n            metadata = { name: key, required: false, access: AccessType.BOTH };\r\n        }\r\n        // tslint:disable-next-line:triple-equals\r\n        if (AccessType.WRITE_ONLY != metadata.access) {\r\n            /**\r\n             * Check requried property\r\n             */\r\n            if (metadata.required && json[metadata.name] === undefined) {\r\n                throw new JsonConverstionError(`JSON structure does have have required property '${metadata.name}' as required by '${getTypeNameFromInstance(objectInstance)}[${key}]`, json);\r\n            }\r\n            // tslint:disable-next-line:triple-equals\r\n            const jsonKeyName = metadata.name != undefined ? metadata.name : key;\r\n            // tslint:disable-next-line:triple-equals\r\n            if (json[jsonKeyName] != undefined) {\r\n                /**\r\n                 * If metadata has deserializer, use that one instead.\r\n                 */\r\n                // tslint:disable-next-line:triple-equals\r\n                if (metadata.deserializer != undefined) {\r\n                    objectInstance[key] = getOrCreateDeserializer(metadata.deserializer).deserialize(json[jsonKeyName]);\r\n                } else if (metadata.type === undefined) {\r\n                    /**\r\n                    * If we do not have any type defined, then we can't do much here but to hope for the best.\r\n                    */\r\n                    objectInstance[key] = json[jsonKeyName];\r\n                } else {\r\n                    if (!isArrayType(objectInstance, key)) {\r\n                        // tslint:disable-next-line:triple-equals\r\n                        const typeName = metadata.type != undefined ? getTypeNameFromInstance(metadata.type) : getTypeName(objectInstance, key);\r\n                        if (!isSimpleType(typeName)) {\r\n                            objectInstance[key] = new metadata.type();\r\n                            conversionFunctionsList.push({ functionName: Constants.OBJECT_TYPE, type: metadata.type, instance: objectInstance[key], json: json[jsonKeyName] });\r\n                        } else {\r\n                            conversionFunctions[typeName](objectInstance, key, typeName, json, jsonKeyName);\r\n                        }\r\n                    } else {\r\n                        const moreFunctions: Array<ConversionFunctionStructure> = conversionFunctions[Constants.ARRAY_TYPE](objectInstance, key, metadata.type, json, jsonKeyName);\r\n                        moreFunctions.forEach((struct: ConversionFunctionStructure) => {\r\n                            conversionFunctionsList.push(struct);\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    });\r\n\r\n    return conversionFunctionsList;\r\n};\r\n\r\n/**\r\n * Conversion function parameters structure that will be used to call the function.\r\n */\r\nexport interface ConversionFunctionStructure {\r\n    functionName: string;\r\n    instance: any;\r\n    instanceKey?: string;\r\n    type?: any;\r\n    json: any;\r\n    jsonKey?: string;\r\n}\r\n\r\n/**\r\n * Object to cache deserializers\r\n */\r\nexport const deserializers = {};\r\n\r\n/**\r\n * Checks to see if the deserializer already exists or not.\r\n * If not, creates a new one and caches it, returns the\r\n * cached instance otherwise.\r\n */\r\nexport const getOrCreateDeserializer = (type: any): any => {\r\n    return getCachedType(type, deserializers);\r\n};\r\n\r\n/**\r\n * List of JSON object conversion functions.\r\n */\r\nexport const conversionFunctions = {};\r\nconversionFunctions[Constants.OBJECT_TYPE] = DeserializeComplexType;\r\nconversionFunctions[Constants.ARRAY_TYPE] = DeserializeArrayType;\r\nconversionFunctions[Constants.DATE_TYPE] = DeserializeDateType;\r\nconversionFunctions[Constants.STRING_TYPE] = DeserializeSimpleType;\r\nconversionFunctions[Constants.NUMBER_TYPE] = DeserializeSimpleType;\r\nconversionFunctions[Constants.BOOLEAN_TYPE] = DeserializeSimpleType;\r\nconversionFunctions[Constants.FROM_ARRAY] = SimpleTypeCoverter;\r\nconversionFunctions[Constants.OBJECT_TYPE_LOWERCASE] = DeserializeComplexType;\r\nconversionFunctions[Constants.ARRAY_TYPE_LOWERCASE] = DeserializeArrayType;\r\nconversionFunctions[Constants.DATE_TYPE_LOWERCASE] = DeserializeDateType;\r\nconversionFunctions[Constants.STRING_TYPE_LOWERCASE] = DeserializeSimpleType;\r\nconversionFunctions[Constants.NUMBER_TYPE_LOWERCASE] = DeserializeSimpleType;\r\nconversionFunctions[Constants.BOOLEAN_TYPE_LOWERCASE] = DeserializeSimpleType;\r\n","import { AccessType, CacheKey, JsonPropertyDecoratorMetadata, Serializer } from './DecoratorMetadata';\nimport { Constants, getCachedType, getJsonPropertyMetadata, getKeyName, isSimpleType, METADATA_JSON_IGNORE_NAME } from './ReflectHelper';\n\ndeclare var Reflect: any;\n\nexport interface SerializationStructure {\n    id: string; /** id of the current structure */\n    type: string; /** 'object' or 'array' */\n    instance: any; /** Object instance to serialize */\n    values: Array<String>; /** Array of current current instance's key value pairs */\n    parentIndex: number; /** Parent's index position in the stack */\n    key: string; /** the parent object's key name for this object instance. Options as it is not required for arrays */\n    visited: boolean; /** Indicates if this node has been visited or not */\n}\n\nexport const SerializeArrayType = (parentStructure: SerializationStructure, instanceStructure: SerializationStructure, instanceIndex: number): Array<SerializationStructure> => {\n    const furtherSerializationStructures: Object = {};\n    const arrayInstance: Array<any> = instanceStructure.instance as Array<any>;\n    instanceStructure.visited = true;\n    arrayInstance.forEach((value: any) => {\n        if (value !== undefined) {\n            if (!isSimpleType(typeof value)) {\n                const struct: SerializationStructure = {\n                    id: uniqueId(),\n                    type: Constants.OBJECT_TYPE,\n                    instance: value,\n                    parentIndex: instanceIndex,\n                    values: [],\n                    key: undefined,\n                    visited: false\n                };\n                furtherSerializationStructures[struct.id] = struct;\n            } else {\n                instanceStructure.values.push(serializeFunctions[typeof value](undefined, value, serializers[typeof value]));\n            }\n        }\n    });\n\n    return createArrayOfSerializationStructures(furtherSerializationStructures);\n};\n\nconst createArrayOfSerializationStructures = (serializationStructuresObject: Object) => {\n    const serializationStructures: Array<SerializationStructure> = [];\n    Object.keys(serializationStructuresObject).forEach((key: string) => {\n        serializationStructures.push(serializationStructuresObject[key]);\n    });\n    return serializationStructures;\n};\n\nexport const serializeObject = (key: string, instanceValuesStack: Array<String>): string => {\n    const json = (key !== undefined ? `\"${key}\":` : '');\n    return `${json}{${instanceValuesStack.join()}}`;\n};\n\nexport const serializeArray = (key: string, instanceValuesStack: Array<String>): string => {\n    const json = (key !== undefined ? `\"${key}\":` : '');\n    return `${json}[${instanceValuesStack.join()}]`;\n};\n\nexport const mergeObjectOrArrayValuesAndCopyToParents = (instanceStructure: SerializationStructure, parentStructure: SerializationStructure): void => {\n    mergeObjectOrArrayValues(instanceStructure);\n    parentStructure.values.push(instanceStructure.values.pop());\n};\n\nexport const mergeObjectOrArrayValues = (instanceStructure: SerializationStructure): void => {\n    let mergedValue: string;\n    if (instanceStructure.type === Constants.OBJECT_TYPE) {\n        mergedValue = serializeObject(instanceStructure.key, instanceStructure.values);\n    } else {\n        mergedValue = serializeArray(instanceStructure.key, instanceStructure.values);\n    }\n    instanceStructure.values = [];\n    instanceStructure.values.push(mergedValue);\n};\n\nexport const SerializeObjectType = (parentStructure: SerializationStructure, instanceStructure: SerializationStructure, instanceIndex: number): Array<SerializationStructure> => {\n    const furtherSerializationStructures: Object = {};\n    instanceStructure.visited = true;\n    let objectKeys: string[] = Object.keys(instanceStructure.instance);\n    objectKeys = objectKeys.filter((item: string) => {\n        return !Reflect.hasMetadata(METADATA_JSON_IGNORE_NAME, instanceStructure.instance, item);\n    });\n    objectKeys.forEach((key: string) => {\n        const keyInstance = instanceStructure.instance[key];\n        if (keyInstance === null) {\n            instanceStructure.values.push(`\"${key}\":${keyInstance}`);\n        } else if (keyInstance !== undefined) {\n            const metadata: JsonPropertyDecoratorMetadata = getJsonPropertyMetadata(instanceStructure.instance, key);\n\n            if (metadata !== undefined && AccessType.READ_ONLY === metadata.access) {\n                // SKIP\n            } else if (metadata !== undefined && metadata.serializer !== undefined) {\n                const serializer: Serializer = getOrCreateSerializer(metadata.serializer);\n                instanceStructure.values.push(serializeFunctions[Constants.STRING_TYPE](getKeyName(instanceStructure.instance, key), keyInstance, serializer));\n            } else {\n                if (keyInstance instanceof Array) {\n                    const struct: SerializationStructure = {\n                        id: uniqueId(),\n                        type: Constants.ARRAY_TYPE,\n                        instance: keyInstance,\n                        parentIndex: instanceIndex,\n                        values: [],\n                        key: getKeyName(instanceStructure.instance, key),\n                        visited: false\n                    };\n                    furtherSerializationStructures[struct.id] = struct;\n                } else if (!isSimpleType(typeof keyInstance)) {\n                    const struct: SerializationStructure = {\n                        id: uniqueId(),\n                        type: Constants.OBJECT_TYPE,\n                        instance: keyInstance,\n                        parentIndex: instanceIndex,\n                        values: [],\n                        key: getKeyName(instanceStructure.instance, key),\n                        visited: false\n                    };\n                    furtherSerializationStructures[struct.id] = struct;\n                } else {\n                    const serializer: Serializer = serializers[typeof keyInstance];\n                    instanceStructure.values.push(serializeFunctions[typeof keyInstance](getKeyName(instanceStructure.instance, key), keyInstance, serializer));\n                }\n            }\n\n        }\n    });\n\n    return createArrayOfSerializationStructures(furtherSerializationStructures);\n};\n\n/**\n * Serialize any type with key value pairs\n */\nconst SerializeSimpleType = (key: string, instance: any, serializer: Serializer): string => {\n    const value: any = serializer.serialize(instance);\n\n    if (key !== undefined) {\n        return `\"${key}\":${value}`;\n    } else {\n        return value;\n    }\n};\n\n@CacheKey('DateSerializer')\nexport class DateSerializer implements Serializer {\n    serialize = (value: Date): number => {\n        return value.getTime();\n    }\n}\n\n@CacheKey('StringSerializer')\nclass StringSerializer implements Serializer {\n    serialize = (value: string): string => {\n        return JSON.stringify(value);\n    }\n}\n\n@CacheKey('NumberSerializer')\nclass NumberSerializer implements Serializer {\n    serialize = (value: number): number => {\n        return value;\n    }\n}\n\n@CacheKey('BooleanSerializer')\nclass BooleanSerializer implements Serializer {\n    serialize = (value: boolean): boolean => {\n        return value;\n    }\n}\n\n/**\n * Object to cache serializers\n */\nexport const serializers = {};\nserializers[Constants.STRING_TYPE] = new StringSerializer();\nserializers[Constants.NUMBER_TYPE] = new NumberSerializer();\nserializers[Constants.DATE_TYPE] = new DateSerializer();\nserializers[Constants.BOOLEAN_TYPE] = new BooleanSerializer();\nserializers[Constants.STRING_TYPE_LOWERCASE] = serializers[Constants.STRING_TYPE];\nserializers[Constants.NUMBER_TYPE_LOWERCASE] = serializers[Constants.NUMBER_TYPE];\nserializers[Constants.DATE_TYPE_LOWERCASE] = serializers[Constants.DATE_TYPE];\nserializers[Constants.BOOLEAN_TYPE_LOWERCASE] = serializers[Constants.BOOLEAN_TYPE];\n\n/**\n * Checks to see if the serializer already exists or not.\n * If not, creates a new one and caches it, returns the\n * cached instance otherwise.\n */\nexport const getOrCreateSerializer = (type: any): any => {\n    return getCachedType(type, serializers);\n};\n\nexport const serializeFunctions = [];\nserializeFunctions[Constants.STRING_TYPE] = SerializeSimpleType;\nserializeFunctions[Constants.NUMBER_TYPE] = SerializeSimpleType;\nserializeFunctions[Constants.BOOLEAN_TYPE] = SerializeSimpleType;\nserializeFunctions[Constants.DATE_TYPE] = SerializeSimpleType;\nserializeFunctions[Constants.ARRAY_TYPE] = SerializeArrayType;\nserializeFunctions[Constants.OBJECT_TYPE] = SerializeObjectType;\nserializeFunctions[Constants.STRING_TYPE_LOWERCASE] = SerializeSimpleType;\nserializeFunctions[Constants.NUMBER_TYPE_LOWERCASE] = SerializeSimpleType;\nserializeFunctions[Constants.BOOLEAN_TYPE_LOWERCASE] = SerializeSimpleType;\nserializeFunctions[Constants.DATE_TYPE_LOWERCASE] = SerializeSimpleType;\nserializeFunctions[Constants.ARRAY_TYPE_LOWERCASE] = SerializeArrayType;\nserializeFunctions[Constants.OBJECT_TYPE_LOWERCASE] = SerializeObjectType;\n\nconst uniqueId = (): string => {\n    return `${Math.random()}-${Date.now()}`;\n};\n","import { conversionFunctions, ConversionFunctionStructure } from './DeserializationHelper';\r\nimport { Constants } from './ReflectHelper';\r\nimport { mergeObjectOrArrayValues, mergeObjectOrArrayValuesAndCopyToParents, SerializationStructure, serializeFunctions } from './SerializationHelper';\r\n\r\nexport namespace ObjectMapper {\r\n\r\n    /**\r\n     * Deserializes an array of object types with the passed on JSON data.\r\n     */\r\n    export const deserializeArray = <T>(type: { new(): T }, json: Object): T[] => {\r\n        class ObjectsArrayParent {\r\n            instances: T[] = undefined;\r\n        }\r\n\r\n        const parent: ObjectsArrayParent = new ObjectsArrayParent();\r\n        runDeserialization(conversionFunctions[Constants.ARRAY_TYPE](parent, 'instances', type, json, undefined));\r\n\r\n        return parent.instances;\r\n    };\r\n\r\n    /**\r\n     * Deserializes a Object type with the passed on JSON data.\r\n     */\r\n    export const deserialize = <T>(type: { new(): T }, json: Object): T => {\r\n        const dtoInstance = new type();\r\n        const conversionFunctionStructure: ConversionFunctionStructure = {\r\n            functionName: Constants.OBJECT_TYPE,\r\n            instance: dtoInstance,\r\n            json: json,\r\n        };\r\n\r\n        runDeserialization([conversionFunctionStructure]);\r\n\r\n        return dtoInstance;\r\n    };\r\n\r\n    const runDeserialization = (conversionFunctionStructures: ConversionFunctionStructure[]): void => {\r\n\r\n        const converstionFunctionsArray: Array<ConversionFunctionStructure> = [];\r\n        conversionFunctionStructures.forEach((struct: ConversionFunctionStructure) => {\r\n            converstionFunctionsArray.push(struct);\r\n        });\r\n\r\n        let conversionFunctionStructure: ConversionFunctionStructure = converstionFunctionsArray[0];\r\n\r\n        // tslint:disable-next-line:triple-equals\r\n        while (conversionFunctionStructure != undefined) {\r\n            const stackEntries: Array<ConversionFunctionStructure> = conversionFunctions[conversionFunctionStructure.functionName](\r\n                conversionFunctionStructure.instance, conversionFunctionStructure.instanceKey,\r\n                conversionFunctionStructure.type, conversionFunctionStructure.json,\r\n                conversionFunctionStructure.jsonKey);\r\n            stackEntries.forEach((structure: ConversionFunctionStructure) => {\r\n                converstionFunctionsArray.push(structure);\r\n            });\r\n            conversionFunctionStructure = converstionFunctionsArray.pop();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Serializes an object instance to JSON string.\r\n     */\r\n    export const serialize = (obj: any): String => {\r\n        const stack: Array<SerializationStructure> = [];\r\n        const struct: SerializationStructure = {\r\n            id: undefined,\r\n            type: Array.isArray(obj) === true ? Constants.ARRAY_TYPE : Constants.OBJECT_TYPE,\r\n            instance: obj,\r\n            parentIndex: undefined,\r\n            values: [],\r\n            key: undefined,\r\n            visited: false\r\n        };\r\n\r\n        stack.push(struct);\r\n\r\n        do {\r\n            const instanceStruct: SerializationStructure = stack[stack.length - 1];\r\n            const parentStruct: SerializationStructure = stack[stack.length > 1 ? instanceStruct.parentIndex : 0];\r\n            if (instanceStruct.visited) {\r\n                mergeObjectOrArrayValuesAndCopyToParents(instanceStruct, parentStruct);\r\n                stack.pop();\r\n            } else {\r\n                const moreStructures: Array<SerializationStructure> = serializeFunctions[instanceStruct.type](parentStruct, instanceStruct, stack.length - 1);\r\n                if (moreStructures.length > 0) {\r\n                    let index = moreStructures.length;\r\n                    while (--index >= 0) {\r\n                        stack.push(moreStructures[index]);\r\n                    }\r\n                } else {\r\n                    if (stack.length > 1) {\r\n                        mergeObjectOrArrayValuesAndCopyToParents(instanceStruct, parentStruct);\r\n                    }\r\n                    stack.pop();\r\n                }\r\n            }\r\n        } while (stack.length > 1);\r\n\r\n        mergeObjectOrArrayValues(struct);\r\n\r\n        return struct.values[0];\r\n    };\r\n}\r\nexport { JsonProperty, JsonConverstionError, AccessType, CacheKey, JsonIgnore } from './DecoratorMetadata';\r\nexport { DateSerializer } from './SerializationHelper';\r\n"],"names":["AccessType","ObjectMapper"],"mappings":"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"}